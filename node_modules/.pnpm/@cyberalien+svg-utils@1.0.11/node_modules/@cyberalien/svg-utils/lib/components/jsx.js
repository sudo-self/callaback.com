import { getComponentSizeValues } from "./helpers/content/size.js";
import { stringifyFactoryIconContent } from "./helpers/content/stringify.js";
import { stringifyIconViewBox } from "../svg/viewbox/value.js";
import { createFactoryImports } from "./helpers/imports/create.js";
import { generateCSSFilesForComponent } from "./helpers/css/generate.js";
import { addSizeFunctionAsset } from "./helpers/functions/size.js";
import { stringifyFactoryPropsAsJSON } from "./helpers/props/object.js";
import { stringifyFactoryImports } from "./helpers/imports/stringify.js";
import { makeSquareViewBox } from "../svg/viewbox/square.js";
import { getUsedFactoryProps, stringifyFactoryPropTypes } from "./helpers/props/ts.js";
import { minifyViewBox } from "../svg/viewbox/minify.js";
import { getViewBoxRatio } from "./helpers/content/ratio.js";
import { addJSXComponentTypes } from "./helpers/ts/jsx.js";

/**
* Create functional Vue component code
*/
function createJSXComponent(data, options) {
	const useTS = options.ts ?? false;
	const assets = [];
	const imports = createFactoryImports();
	const dependencies = /* @__PURE__ */ new Set();
	let importPackage = "react";
	let createElement = "createElement";
	switch (options.jsx) {
		case "preact":
			importPackage = "preact";
			createElement = "h";
			break;
	}
	const fallbackPackage = options.fallbackPackage || null;
	const hasFallback = !!(fallbackPackage && data.fallback);
	if (hasFallback) {
		imports.named[fallbackPackage] = new Set(["Icon"]);
		dependencies.add(fallbackPackage);
	}
	const reactNamedImports = new Set([createElement]);
	imports.named[importPackage] = reactNamedImports;
	const style = generateCSSFilesForComponent(data.icon, imports, assets, options);
	const isEmbeddedCSS = options.cssMode === "embed";
	let hasFixedSize = !!options.width && !!options.height;
	const viewBox = data.viewBox;
	const hasComputedViewbox = options.square && !hasFixedSize && viewBox.width !== viewBox.height;
	const isStringViewBox = !hasFallback;
	const hasComputedRatio = hasComputedViewbox && isStringViewBox;
	if (!hasComputedViewbox && (options.width || options.height)) hasFixedSize = true;
	const componentExternalCode = [];
	const componentInternalCode = [];
	const props = {};
	if (!hasFallback) props.xmlns = "http://www.w3.org/2000/svg";
	props.props = {
		value: "props",
		template: "...props,"
	};
	const getViewBox = (viewBox$1) => isStringViewBox ? `'${stringifyIconViewBox(viewBox$1)}'` : JSON.stringify(minifyViewBox(viewBox$1));
	if (hasComputedViewbox) {
		componentExternalCode.push(`const baseViewBox = ${getViewBox(viewBox)};`, `const squareViewBox = ${getViewBox(makeSquareViewBox(viewBox))};`);
		componentInternalCode.push(`const viewBox = useMemo(() => square ? squareViewBox : baseViewBox, [square]);`);
	} else componentExternalCode.push(`const viewBox = ${getViewBox(viewBox)};`);
	const ratioValue = getViewBoxRatio(viewBox);
	if (hasComputedRatio) componentInternalCode.push(`const ratio = useMemo(() => square ? 1 : ${ratioValue}, [square]);`);
	if (hasFixedSize) {
		const sizeProps = getComponentSizeValues(options, data.viewBox);
		if (!sizeProps) throw new Error("Fixed size expected, but could not be determined");
		props.width = sizeProps.width;
		props.height = sizeProps.height;
	} else if (hasFallback) {
		props.width = {
			type: "string",
			value: "width",
			template: "width,"
		};
		props.height = {
			type: "string",
			value: "height",
			template: "height,"
		};
	} else {
		const getSizeProps = addSizeFunctionAsset(imports, assets, options);
		componentInternalCode.push(`const size = useMemo(() => ${getSizeProps}(width, height, ${hasComputedRatio ? "ratio" : ratioValue}), [width, height${hasComputedRatio ? ", ratio" : ""}]);`);
		reactNamedImports.add("useMemo");
		props.width = {
			type: "string",
			value: "width",
			template: "...size,"
		};
		props.height = {
			type: "string",
			value: "height",
			template: ""
		};
	}
	if (options.square) props.square = { type: "boolean" };
	props.viewBox = {
		value: "viewBox",
		template: "viewBox,"
	};
	props.content = {
		value: stringifyFactoryIconContent(data.icon, options, isEmbeddedCSS ? style : void 0),
		template: hasFallback ? void 0 : "dangerouslySetInnerHTML: {__html: {value}},"
	};
	if (hasFallback && data.fallback) props.fallback = data.fallback;
	componentInternalCode.push(`return ${createElement}(${hasFallback ? "Icon" : "'svg'"}, {
\t\t${stringifyFactoryPropsAsJSON(props, "\n		")}
\t});`);
	const beforeFunction = componentExternalCode.length ? componentExternalCode.join("\n") + "\n\n" : "";
	const usedProps = getUsedFactoryProps(props);
	const propsDestricturing = usedProps.length ? `{${[...usedProps, "...props"].join(", ")}}` : "props";
	const componentFunction = `function Component${useTS ? `<{\n${stringifyFactoryPropTypes(props)}\n}>` : ""}(${propsDestricturing}) {
\t${componentInternalCode.join("\n	")}
}
`;
	const content = `${stringifyFactoryImports(imports)}\n${beforeFunction}${componentFunction}\nexport default Component;\n`;
	const types = addJSXComponentTypes(data, options, assets, props);
	return {
		assets,
		content,
		style: isEmbeddedCSS ? void 0 : style,
		types,
		dependencies: dependencies.size ? dependencies : void 0
	};
}

export { createJSXComponent };